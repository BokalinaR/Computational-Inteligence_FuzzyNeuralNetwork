% !TEX encoding = UTF-8 Unicode
\documentclass[a4paper]{article}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={150mm,240mm},
 left=30mm,
 top=30mm,
 }

\usepackage{color}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}
%\usepackage[]{algorithm2e}
\usepackage{caption}
\usepackage{float}

\usepackage[english,serbian]{babel}
%\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

\usepackage{listings}

%\newtheorem{primer}{Пример}[section] %ćirilični primer
\newtheorem{primer}{Primer}[section]

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\scriptsize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  firstnumber=1000,                % start line enumeration with line 1000
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Python,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}

\title{Fazi neuronska mreža\\ \small{Seminarski rad u okviru kursa\\Računarska inteligencija\\ Matematički fakultet}}

\author{Katarina Savičić, Bojana Ristanović\\ mi16261@alas.matf.bg.ac.rs, mi16045@alas.matf.bg.ac.rs}

\maketitle

\abstract{
U ovom radu će biti predstavljena fazi neuronska mreža. Konkretnije, ovaj metod je korišćen kao metod klasifikacije podataka,
koji u trening fazi koristi min-max algoritam, a u test fazi koristi k najbližih suseda. Nakon opisa algoritma, prikaza je njegova
praktična primena. Na kraju, rezultati su upoređeni sa autorima rada \emph{Understanding Fuzzy Neural Network using code and animation}.
\\
\\
\textbf{Ključne reči:} fazi logika, neuronske mreže, min-max, knn, klasifikacija.
}
\tableofcontents

\newpage

\section{Uvod}
\label{sec:uvod}

Fazi neuronska mreža (eng. \emph{Fuzzy neural network}) je sistem za učenje koji pronalazi parametre fazi sistema koristeći tehnike aproksimacije neuronskih mreža. To je hibridni inteligentni sistem koji kombinuje tehnike rasuđivanja fazi logike sa tehnikama učenja neuronskih mreža.\cite{fnn}

Fazi min-max klasfikator (eng. \emph{The fuzzy min–max (FMM)}) je sistem koji formira hiperboksove za klasifikaciju i predviđanje. U ovom radu je pokušana modifikacija FMM-a korišćenjem algoritma k najbližih suseda (eng. \emph{k-nearest neighbors algorithm (k-NN)}) u procesu predviđanja klasa prosleđenih podataka.

\section{Fazi logika}
\label{fazilogika}
Kod klasične logike, promenljive mogu uzeti jedino vrednosti 1 ili 0 (tačno ili netačno). Kod fazi logike se skup vrednosti proširuje, pri čemu 
se dozvoljava da promenljive mogu uzeti realne vrednosti unutar nekog intervala. Drugim rečima, pretpostavlja se da ne mora sve biti u 
potpunosti istinito ili u potpunosti neistinito, već se dozvoljava određen nivo delimične istine. Na primer, za nešto možemo reći da je 
najverovatnije istina, pa odgovarajuća promenljiva može imati vrednost 0.9, a u nešto drugo možemo imati veliku sumnju, ali ostavljati 
malu verovatnoću da bude istinito, pa odgovarajuća logička promenljiva tada može imati vrednost 0.1. \cite{fl}

Da li nešto pripada skupu možemo odrediti pomoću funkcije pripadnosti. Ona kod klasične logike ima vrednost 0 ili 1, zato što nešto može 
ili ne da pripada skupu. Kod fazi logike ova funkcija ima vrednost između 0 i 1. \cite{fl}


\section{Neuronske Mreže}
\label{neuronskemreze}


\section{Fazi min-max klasifikator}
\label{faziminmaxcl}

Osnovna ideja je da se na osnovu funkcije pripadnosti koja se koristi u Fazi logici može odrediti kojoj klasi pripada instanca koju 
klasifikujemo. U ovom slučaju instanca je uređeni par realnih brojeva, koji se može predstaviti kao tačka u koordinatnom sistemu. 
Klasa instance će biti ona za koju funkcija pripadnosti daje najveću vrednost. Postavlja se pitanje kako predstaviti fazi skup.\cite{mmf}

\subsection{Hiperboks  (eng. \emph{Hyperbox})}
\label{hiperboks}

Fazi skup možemo definisati kao pravougaonik čije dužine stranica mogu uzimati vrednost od 0 do 1. Ovaj skup je takav da ako se tačka 
nalazi unutar pravouganika, vrednost njene funkcije pripadnosti je 1. Pravougaonik je definisan svojom najmanjom (donjom levom) i 
najvećom (gornjom desnom) tačkom. Te tačke ćemo označiti redom slovima v i w.

Vrednost funkcije pripadnosti za svaku tačku koja je van pravougaonika se smanjuje sa povećanjem udaljenosti tačke od pravougaonika. 
Formula za računanje funkcije pripadnosti nekom pravougaoniku, tj. fazi skupu, je data u nastavku:

\begin{equation}
    b_j(A_h) = \frac{1}{2n}\sum_{i=1}^{n}[max(0, 1 - max(0, \gamma min(1, a_{hi}-w_{ji}))) + max(0, 1 - max(0, \gamma min(1, v_{ji}-a_{hi})))]
\end{equation}

$A_h$ obrazac za koji računamo funkciju pripadnosti, $b_j$ fazi skup a $n$ dimenzija (u našem slučaju 2). $\gamma$ je hiperparametar 
koji se naziva osetljivost ili stopa smanjenja i može se koristiti za kontrolisanje vrednosti funkcije pripadnosti.

Kod neuronske mreže imamo prvi sloj koji predstavlja ulazne čvorove za podatke. Sledeći sloj su čvorovi koji predstavljaju hiperbokseve, tj. 
svaki čvor predtavlja jedan hiperboks koji pripada nekoj klasi i definisan je dvema tačkama. Hiperboks je prethodno pomenuti 
pravougaonik. Poslednji sloj čvorova predstavlja izlaz, odnosno klasu. U poslednjem sloju može biti više čvorova, u zavisnosti od broja 
postojećih klasa. Kada gledamo vrednost klase, svaki čvor koji predtavlja klasu definisan je njavećom vrednošću funkcije pripadnosti od 
svih funkcija pripadnosti računate za sve hiperbokseve koje pripadaju datoj klasi. Dakle, svaka klasa može imati jedan ili više hiperbokseva, 
vrednost u čovoru je maksimalna vrednost funkcije pripadnosti razmatranog podatka tim hiperboksevima. Na kraju se porede vrednosti u 
svim čvorovima koji predtavljaju klase i bira se klasa koja ima najveću vrdnost. \cite{mmf}

\subsection{Algoritam}
\label{algoritam}

Kako bismo sproveli pomenuti način klasifikacije, potrebno je da definišemo hiperbokseve za sve klase. To ćemo uraditi na osnovu skupa za 
treniranje, odnosno istreniraćemo klasifikator tako što ćemo napraviti hiperbokseve za postojeće klase. Algoritam se sastoji iz dve faze: 
proširenja i kontrakcije. \cite{mmf}

\subsubsection{Faza proširenja}
\label{prosirenje}

Imamo instancu $X_h$ iz trening skupa, koja pripada klasi $Y$. Prvo proverimo sve hiperbokseve koji pripadaju klasi Y i računamo funkciju 
pripadnosti za svaki. Hiperboks sa najvećom funkcijom pripadnosti je najpogodniji za proširenje. Neka $B_j$ bude jedan takav hiperboks. 
Pre nego što ga proširimo računamo kriterijum ekspaztije dat sledećom formulom:

\begin{equation}
    n\theta >= \sum_{i=1}^{n}(max(w_{ji}, x_{hi}) - min(v_{ji}, x_{hi}))
\end{equation}

gde je $\theta$ hiper parametar koji predstavlja kriterjum proširenja i kontroliše maksimalno proširenje dozvoljeno za hiperboks. Ako 
zadovoljava kriterijum, hiperboks se širi na sledeći način:

\begin{equation}
    v_{ji}^{new} = min(v_{ji}^{old}, x_{hi})
    w_{ji}^{new} = min(w_{ji}^{old}, x_{hi})
\end{equation}

gde su v i w minimalna i maksimalna tačka hiperboksa. Hiperboks se čiri tako da je $X_h$ uključena u region.

Ukoliko kriterijum širenja nije zadovoljen, pravi se novi hiperboks za klasu $Y$, takav da su mu minimalna i maksimalna tačka jednake i 
imaju vrednost $X_h$. Kada proširimo hiperboks, može doći do preklapanja sa drugim hiperboksom. Ovo nije toliko problem ako je u 
pitanju hiperboks iz iste klase, ali jeste ukoliko je u pitanju hiperboks koji pripada nekoj drugoj kasi. Zbog toga imamo fazu kontrakcije.\cite{mmf}

\subsubsection{Faza kontrakcije}
\label{kontrakcija}

Pronašli smo hiperboks koji smo proširili i sada treba da proverimo da li postoji preklapanje sa drugim hiperboksom. Dozvoljeno je 
preklapanje izmedju iperbokseva iste klase, pa treba samo da proverimo za hiperbokseve drugih klasa.

Proveru da li postoji preklapnje vršimo preko tačaka koje odredjuju hiperbokseve. Gledamo po svim dimenzijama da li postoji preklapanje i 
beležimo rezultate. Onda tražimo dimenziju po kojoj je preklapanje najmanje. Slučajevi koji pokrivaju proveru proveru preklapanja su dati u 
kodu. Kada nađemo dimenziju po kojoj je preklapanje minimalo, hoćemo da smanjimo hiperboks po toj dimenziji. Slučajevi koji pokrivaju 
način smanjenja hiperboksa takođe se nalaze u kodu i neće biti predstavljeni ovde.

Poenta celog algoritma je naći odgovarajući hiperboks, proširiti ga ako je to moguće, ako ne naći drugi koji je moguće proširiti, ili dodati 
novi, proveriti da li postoji preklapanje i izvršiti kontrakciju ukoliko postoji. \cite{mmf}

\subsection{Modifikacije algoritma}

U originalnom algoritmu se za određivanje klase uzima samo najveća vrednost klase, koja predstavlja najveću vrednost funkcije pripadnosti 
za hiperbokseve te klase. Mi smo algoritam izmenili tako da ne gleda jednu najveću vrednost već uzima u obzir nekoliko vrednosti.
Umesto da gledamo funkcije pripadnosti i tražimo najveće vrdnosti, gledali smo rastojanje svake tačke od hiperboksa i tražili najmanje 
rastojanje. Pretpostavili smo da rastojanje od hiperboksa možemo posmatrati kao rastojanje od prave koja prolazi kroz tačke koje određuju 
hiperboks. Sortirali smo rastojanja od svih hiperbokseva rastuće i primenili metod k najbližih suseda. Metod smo primenili tako što smo 
uzeli k najmanjih rastojanja, gledali kojim klasama pripadaju hiperboksevi i kao klasu instance uzeli najbrojniju klasu među 
hiperboksevima.


\section{Rezultati}
\label{neuronskemreze}


\section{Zaključak}
\label{sec:zakljucak}

\addcontentsline{toc}{section}{Literatura}
\appendix
\bibliography{seminarski} 
\bibliographystyle{plain}

\newpage
\appendix


\end{document}
